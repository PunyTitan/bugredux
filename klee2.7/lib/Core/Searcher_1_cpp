//===-- Searcher.cpp ------------------------------------------------------===//
//
//                     The KLEE Symbolic Virtual Machine
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "Common.h"

#include "Searcher.h"

#include "CoreStats.h"
#include "Executor.h"
#include "PTree.h"
#include "StatsTracker.h"

#include "klee/ExecutionState.h"
//#include "klee/Executor.h";
#include "klee/Statistics.h"
#include "klee/Internal/Module/InstructionInfoTable.h"
#include "klee/Internal/Module/KInstruction.h"
#include "klee/Internal/Module/KModule.h"
#include "klee/Internal/ADT/DiscretePDF.h"
#include "klee/Internal/ADT/RNG.h"
#include "klee/Internal/Support/ModuleUtil.h"
#include "klee/Internal/System/Time.h"

#include "llvm/Constants.h"
#include "llvm/Instructions.h"
#include "llvm/Module.h"
#include "llvm/Support/CallSite.h"
#include "llvm/Support/CFG.h"
#include "llvm/Support/CommandLine.h"

#include <cassert>
#include <fstream>
#include <sstream>
#include <climits>

using namespace klee;
using namespace llvm;

cl::opt<bool>
InitEnv("init-env",
	  cl::desc("Create custom environment.  Options that can be passed as arguments to the programs are: --sym-argv <max-len>  --sym-argvs <min-argvs> <max-argvs> <max-len> + file model options"));


namespace {
  cl::opt<bool>
  DebugLogMerge("debug-log-merge");


}


namespace klee {
  extern RNG theRNG;
}

Searcher::~Searcher() {
}


///

int ShortestPathSearcher::getDistanceForBB(BasicBlock* bb, Instruction* tinst) {
	int distance = 1;
	for (BasicBlock::iterator I=bb->begin(), E=bb->end();I!=E;I++) {
		Instruction* inst = I;
		if (tinst!=NULL&&tinst==inst) {
			return distance;
		}
		if (isa<CallInst>(inst)) {
			CallInst* cinst = (CallInst*)inst;
			if (funcShortMap.find((Function*)cinst->getCalledFunction())!=funcShortMap.end()) {
				distance+=funcShortMap[(Function*)cinst->getCalledFunction()]+1;
			}
		}
	}
	return distance;
}

llvm::BasicBlock* ShortestPathSearcher::findBBFromSourceLine(std::string sourceline) {

	for (unsigned i=0;i<functions.size();i++) {
		KFunction* kf = functions[i];
		int numInst = kf->numInstructions;
		for (int j=0;j<numInst;j++) {
			KInstruction* ki = kf->instructions[j];
			std::ostringstream osstream;
			osstream << ki->info->file <<":"<<ki->info->line;
//			std::cerr << osstream.str() << "\n";
			if (osstream.str().compare(sourceline)==0) {

				BasicBlock* curBB = ki->inst->getParent();
				//calc All distance to that targetBB;
				std::cerr <<"found"<<sourceline<<"\n";
				std::cerr << ki->inst->getParent()->getNameStr() <<"\n";
				ki->inst->dump();
				//std::cerr << (*(ki->inst)) <<"\n";
				return curBB;
//				targetBBList.push_back(curBB);
//					generateNewShortDistance();
			}
		}
	}

}

ShortestPathSearcher::ShortestPathSearcher(Executor &_executor)
  : executor(_executor),
    functions(executor.kmodule->functions){
	for (unsigned i=0;i<functions.size();i++) {
		KFunction * kf = functions[i];
		if (kf->function!=NULL) {
			funcShortMap[kf->function] = 1;
		}

	}
// run 5 times to get approximate short dis for func
	for (unsigned i=0;i<functions.size()*5;i++) {
		KFunction * kf = functions[i%functions.size()];
		llvm::Function* curFunc = kf->function;
		int infinity = 10000000;
	//	std::set<BasicBlock*> s;
		std::set<BasicBlock*> q;
		BasicBlock* lastBB;
		std::map<BasicBlock*,int> curFuncMap;
		//cerr << curFunc->getBasicBlockList().size()<<"\n";
		if (curFunc->getBasicBlockList().size()==0)
			continue;
		for (Function::iterator I=curFunc->begin(), E=curFunc->end();I!=E;I++) {
			BasicBlock *BB = I;
			pred_iterator PI = pred_begin(BB), PE = pred_end(BB);
			if (PI!=PE||BB==&(curFunc->getEntryBlock())) {
				lastBB = BB;
				//cerr<<"-\t"<<lastBB->getNameStr()<<"\n";
				curFuncMap[BB] = infinity;
			    q.insert(BB);

			  }
		}

		BasicBlock* entry = &(curFunc->getEntryBlock());
		curFuncMap[entry] = getDistanceForBB(entry,NULL);
		while (q.size()>0) {
			   std::set<BasicBlock*>::iterator it;
			   BasicBlock* minBB = NULL;
			   int minval = infinity;
			   for (it = q.begin();it!=q.end();it++) {
			    	BasicBlock* cbb = *it;

			    	if (curFuncMap[cbb]<minval) {
						minval = curFuncMap[cbb];
			    		minBB = cbb;
			    	}
			   }
		//	   cerr<<"get min BB:" << minBB->getNameStr() << "\n";
			   q.erase(minBB);
	//		   s.insert(minBB);
			   int succNum = minBB->getTerminator()->getNumSuccessors();
			   for (int i=0;i<succNum;i++) {
					BasicBlock * succBB = minBB->getTerminator()->getSuccessor(i);
					int succDis = getDistanceForBB(succBB,NULL);
			//		cerr<<"succ dis for :"<<succBB<<" is "<<succDis<<"\n";
					if (curFuncMap[succBB]>minval+succDis) {
							curFuncMap[succBB]=minval+succDis;
					}
				}

	//		    cerr<<q.size()<<"\n";

			}
//			cerr << lastBB->getNameStr() << "\n";
//			cerr << curFuncMap[lastBB] << "\n";
			funcShortMap[curFunc] = curFuncMap[lastBB];
	}

	//load stack trace file

	callStackPtr = 0;

	changeTargetBB = NULL;

	std::ifstream changeFile("changeTarget", std::ifstream::in);
	//only need the first line in cur version.
	if (changeFile.good()) {
		char line[1024];
		changeFile.getline(line,1024);
		std::string linestr(line);
		changeTargetSource = linestr;
		changeTargetBB = this->findBBFromSourceLine(changeTargetSource);
		generateChangeDis();
	}
	changeFile.close();

	std::ifstream historyFile("stackHistory", std::ifstream::in);
	std::vector<std::string> funcList;
	while (historyFile.good()) {
		char line[1024];
		historyFile.getline(line,1024);
		std::string linestr(line);
		size_t strfound;
		strfound=linestr.find_first_of(":");

		if (strfound==std::string::npos)
			continue;
		size_t funcfound;
		funcfound=linestr.find_first_of("@");
		if (funcfound==std::string::npos) {
			callStack.push_back(linestr);
			break;
		}
		std::string lineinfo = linestr.substr(0,funcfound);
		std::string funcName = linestr.substr(funcfound+1);
		callStack.push_back(lineinfo);
		funcList.push_back(funcName);
	}
	historyFile.close();

	for (unsigned i=0;i<callStack.size()-1;i++) {
		std::string linestr = callStack[i];
		std::string callFuncStr = funcList[i];
		bool found = false;
		for (unsigned i=0;i<functions.size();i++) {
			KFunction* kf = functions[i];
			int numInst = kf->numInstructions;
			for (int j=0;j<numInst;j++) {
				KInstruction* ki = kf->instructions[j];
				std::ostringstream osstream;
				osstream << ki->info->file <<":"<<ki->info->line;
	//			std::cerr << osstream.str() << "\n";
				if (osstream.str().compare(linestr)==0) {
					if (!isa<CallInst>(ki->inst))
						continue;
					if (((CallInst*)ki->inst)->getCalledFunction()!=NULL) {
					std::string calledName = ((CallInst*)ki->inst)->getCalledFunction()->getNameStr();
					if (calledName.compare(callFuncStr)!=0)
						continue;
					} else {
						std::cerr << "get called function is null\n";
					}

					BasicBlock* curBB = ki->inst->getParent();
					//calc All distance to that targetBB;
					std::cerr <<"found"<<linestr<<"\n";
					std::cerr << ki->inst->getParent()->getNameStr() <<"\n";
					ki->inst->dump();
					//std::cerr << (*(ki->inst)) <<"\n";
					found =true;
					targetBBList.push_back(curBB);
//					generateNewShortDistance();
					break;
				}
			}
			if (found)
				break;
		}


	}
	std::string lasttarget = callStack[callStack.size()-1];
	BasicBlock* lastBB = this->findBBFromSourceLine(lasttarget);
	targetBBList.push_back(lastBB);

	for (unsigned i=0;i<callStack.size();i++) {
		std::cerr<<callStack[i]<<"\n";
	}
	this->getTarget = false;
	findNextTarget();

}

void ShortestPathSearcher::generateChangeDis() {
	this->changeTargetDisMap.clear();

	int infinity = 10000000;
	//std::set<BasicBlock*> s;
	std::set<BasicBlock*> q;
	for (unsigned i=0;i<functions.size();i++) {
		KFunction * kf = functions[i];
		Function* curFunc = kf->function;

	for (Function::iterator I=curFunc->begin(), E=curFunc->end();I!=E;I++) {
		BasicBlock *BB = I;
			pred_iterator PI = pred_begin(BB), PE = pred_end(BB);
			if (PI!=PE||BB==&(curFunc->getEntryBlock())) {
				//cerr<<"-\t"<<lastBB->getNameStr()<<"\n";
				changeTargetDisMap[BB] = infinity;
				q.insert(BB);
			}
		}
	}

	changeTargetDisMap[changeTargetBB] = 0;
	while (q.size()>0) {
		   std::set<BasicBlock*>::iterator it;
		   BasicBlock* minBB = NULL;
		   int minval = infinity;
		   for (it = q.begin();it!=q.end();it++) {
		    	BasicBlock* cbb = *it;

		    	if (changeTargetDisMap[cbb]<minval) {
					minval = changeTargetDisMap[cbb];
		    		minBB = cbb;
		    	}
		   }
		   if (minval==infinity)
			   break;
	//	   cerr<<"get min BB:" << minBB->getNameStr() << "\n";
		   q.erase(minBB);
//		   s.insert(minBB);
		   pred_iterator PI = pred_begin(minBB), PE = pred_end(minBB);
		   std::string funcName = minBB->getParent()->getNameStr();
		   if ((minBB==&(minBB->getParent()->getEntryBlock()))/*&&(funcName.compare("__user_main")==0)*/) {
			   Function* calledFunc = minBB->getParent();
			   //find all call site for calledFunc can traverse all CallInst in module
				for (unsigned i=0;i<functions.size();i++) {
					KFunction * kf = functions[i];
					KInstruction** instList = kf->instructions;
					for (unsigned j=0;j<kf->numInstructions;j++) {
						if (isa<CallInst>(instList[j]->inst)) {
							CallInst* cinst = (CallInst*)instList[j]->inst;
							if (cinst->getCalledFunction()==calledFunc) {
								//use approximate here may improve by calcing seperate call site
								BasicBlock* predBB = cinst->getParent();
								int predDis = getDistanceForBB(predBB,cinst);
								if (this->changeTargetDisMap[predBB]>changeTargetDisMap[minBB]+predDis) {
									this->changeTargetDisMap[predBB] = changeTargetDisMap[minBB] + predDis;
								}
							}
						}
					}
				}
		   }
		   if (PI!=PE) {
			   while (PI!=PE) {
				   BasicBlock* predBB = (BasicBlock*)(*PI);
				   int predDis = 1;
				   for (BasicBlock::iterator BI = predBB->begin(), BE = predBB->end();BI!=BE;BI++) {
						Instruction* inst = BI;
						if (isa<CallInst>(inst)) {
							CallInst* cinst = (CallInst*)inst;
							Function* calledFunc = (Function*)cinst->getCalledFunction();
							if (funcShortMap.find((Function*)cinst->getCalledFunction())!=funcShortMap.end()) {

								for (Function::iterator FI = calledFunc->begin(), FE = calledFunc->end();FI!=FE;FI++) {
									BasicBlock* fibb = (FI);
									TerminatorInst* tfibb = fibb->getTerminator();
									if (isa<ReturnInst>(tfibb)) {

										if (this->changeTargetDisMap[fibb]>this->changeTargetDisMap[minBB]+predDis) {
											this->changeTargetDisMap[fibb]=this->changeTargetDisMap[minBB]+predDis;
										}
									}
								}
								predDis+=funcShortMap[(Function*)cinst->getCalledFunction()]+1;
							}
						}
				   }
				   if (this->changeTargetDisMap[predBB]>changeTargetDisMap[minBB]+predDis) {
				   		this->changeTargetDisMap[predBB] = changeTargetDisMap[minBB] + predDis;
				   }


				   PI++;
			   }
		   }
		   if (PI==PE)
			   continue;


		}
}


void ShortestPathSearcher::generateNewShortDistance() {
	this->curDistanceMap.clear();

	int infinity = 10000000;
	//std::set<BasicBlock*> s;
	std::set<BasicBlock*> q;
	for (unsigned i=0;i<functions.size();i++) {
		KFunction * kf = functions[i];
		Function* curFunc = kf->function;

	for (Function::iterator I=curFunc->begin(), E=curFunc->end();I!=E;I++) {
		BasicBlock *BB = I;
			pred_iterator PI = pred_begin(BB), PE = pred_end(BB);
			if (PI!=PE||BB==&(curFunc->getEntryBlock())) {
				//cerr<<"-\t"<<lastBB->getNameStr()<<"\n";
				curDistanceMap[BB] = infinity;
				q.insert(BB);
			}
		}
	}

	curDistanceMap[targetBBList[callStackPtr]] = 0;
	while (q.size()>0) {
		   std::set<BasicBlock*>::iterator it;
		   BasicBlock* minBB = NULL;
		   int minval = infinity;
		   for (it = q.begin();it!=q.end();it++) {
		    	BasicBlock* cbb = *it;

		    	if (curDistanceMap[cbb]<minval) {
					minval = curDistanceMap[cbb];
		    		minBB = cbb;
		    	}
		   }
		   if (minval==infinity)
			   break;
	//	   cerr<<"get min BB:" << minBB->getNameStr() << "\n";
		   q.erase(minBB);
//		   s.insert(minBB);
		   pred_iterator PI = pred_begin(minBB), PE = pred_end(minBB);
		   std::string funcName = minBB->getParent()->getNameStr();
		   if ((minBB==&(minBB->getParent()->getEntryBlock()))&&(funcName.compare("__user_main")==0)) {
			   Function* calledFunc = minBB->getParent();
			   //find all call site for calledFunc can traverse all CallInst in module
				for (unsigned i=0;i<functions.size();i++) {
					KFunction * kf = functions[i];
					KInstruction** instList = kf->instructions;
					for (unsigned j=0;j<kf->numInstructions;j++) {
						if (isa<CallInst>(instList[j]->inst)) {
							CallInst* cinst = (CallInst*)instList[j]->inst;
							if (cinst->getCalledFunction()==calledFunc) {
								//use approximate here may improve by calcing seperate call site
								BasicBlock* predBB = cinst->getParent();
								int predDis = getDistanceForBB(predBB,cinst);
								if (this->curDistanceMap[predBB]>curDistanceMap[minBB]+predDis) {
									this->curDistanceMap[predBB] = curDistanceMap[minBB] + predDis;
								}
							}
						}
					}
				}
		   }
		   if (PI!=PE) {
			   while (PI!=PE) {
				   BasicBlock* predBB = (BasicBlock*)(*PI);
				   int predDis = 1;
				   for (BasicBlock::iterator BI = predBB->begin(), BE = predBB->end();BI!=BE;BI++) {
						Instruction* inst = BI;
						if (isa<CallInst>(inst)) {
							CallInst* cinst = (CallInst*)inst;
							Function* calledFunc = (Function*)cinst->getCalledFunction();
							if (funcShortMap.find((Function*)cinst->getCalledFunction())!=funcShortMap.end()) {

								for (Function::iterator FI = calledFunc->begin(), FE = calledFunc->end();FI!=FE;FI++) {
									BasicBlock* fibb = (FI);
									TerminatorInst* tfibb = fibb->getTerminator();
									if (isa<ReturnInst>(tfibb)) {

										if (this->curDistanceMap[fibb]>this->curDistanceMap[minBB]+predDis) {
											this->curDistanceMap[fibb]=this->curDistanceMap[minBB]+predDis;
										}
									}
								}
								predDis+=funcShortMap[(Function*)cinst->getCalledFunction()]+1;
							}
						}
				   }
				   if (this->curDistanceMap[predBB]>curDistanceMap[minBB]+predDis) {
				   		this->curDistanceMap[predBB] = curDistanceMap[minBB] + predDis;
				   }


				   PI++;
			   }
		   }
		   if (PI==PE)
			   continue;


		}
}

void ShortestPathSearcher::findNextTarget() {
	//missing: get current target source line
	int infinity = 10000000;

	if (callStackPtr==callStack.size()) {

		curDistanceMap.clear();
		for (unsigned i=0;i<functions.size();i++) {
			KFunction * kf = functions[i];
			Function* curFunc = kf->function;

		for (Function::iterator I=curFunc->begin(), E=curFunc->end();I!=E;I++) {
			BasicBlock *BB = I;
				pred_iterator PI = pred_begin(BB), PE = pred_end(BB);
				if (PI!=PE||BB==&(curFunc->getEntryBlock())) {
					//cerr<<"-\t"<<lastBB->getNameStr()<<"\n";
					//set to infinity make every bb become can not reach
					curDistanceMap[BB] = infinity;
				}
			}
		}
		return;
	}
	std::string targetSourceLine = callStack[callStackPtr];
	std::cerr << targetSourceLine <<"\n";

	generateNewShortDistance();

	//can't find next target set all to infinity
//	curDistanceMap.clear();
//	for (unsigned i=0;i<functions.size();i++) {
//		KFunction * kf = functions[i];
//		Function* curFunc = kf->function;
//
//	for (Function::iterator I=curFunc->begin(), E=curFunc->end();I!=E;I++) {
//		BasicBlock *BB = I;
//			pred_iterator PI = pred_begin(BB), PE = pred_end(BB);
//			if (PI!=PE||BB==&(curFunc->getEntryBlock())) {
//				//cerr<<"-\t"<<lastBB->getNameStr()<<"\n";
//				//set to 0 make every bb become can not reach
//				curDistanceMap[BB] = infinity;
//			}
//		}
//	}
	return;

}

ShortestPathSearcher::~ShortestPathSearcher() {
}


ExecutionState &ShortestPathSearcher::selectState() {
	//ExecutionState *es = states.back();
	int infinity = 10000000;
	int initenvpos = 0;
	if (InitEnv)
		initenvpos = 1;

	if (this->getTarget==true) {
		ExecutionState* correctState = NULL;
		for (std::vector<ExecutionState*>::iterator it = states.begin(),
		             ie = states.end(); it != ie; ++it) {
			ExecutionState *es = *it;
			if (es->stack.size()>=callStackPtr+initenvpos) {
				bool correctStack = true;
				for (unsigned ui = 1+initenvpos;ui<callStackPtr+initenvpos;ui++) {
					StackFrame sf = es->stack[ui];
					KInstruction* kinst = sf.caller;

					std::ostringstream osstream;
					osstream << kinst->info->file <<":"<<kinst->info->line;

				//	std::cerr<<kinst->info->line<<"\n";
					if (kinst->inst->getParent()!=targetBBList[ui-1-initenvpos]||(osstream.str().compare(callStack[ui-1-initenvpos])!=0)) {
						correctStack = false;
						break;
					}

				}
				if (correctStack) {

				if (es->stack.size()==callStackPtr+initenvpos) {
					std::ostringstream osstream;
					KInstruction* kinst = es->pc;
					osstream << kinst->info->file <<":"<<kinst->info->line;
					if (/*kinst->inst->getParent()==targetBBList[callStackPtr-1]&&*/(osstream.str().compare(callStack[callStackPtr-1])==0)) {
						correctState = es;
					} else {
						std::ostringstream prevosstream;
						KInstruction* kprevinst = es->prevPC;
						prevosstream << kprevinst->info->file <<":"<<kprevinst->info->line;
						if (/*kprevinst->inst->getParent()==targetBBList[callStackPtr-1]&&*/(prevosstream.str().compare(callStack[callStackPtr-1])==0)) {
							correctState = es;
							std::cerr<<"clear state | current line no @ " << kinst->info->line<<"\n";
							states.clear();
						}
					}
				} else {
					KInstruction* kinst = es->stack[callStackPtr+initenvpos].caller;
					std::ostringstream osstream;
					osstream << kinst->info->file <<":"<<kinst->info->line;
					if (/*kinst->inst->getParent()==targetBBList[callStackPtr-1]&&*/(osstream.str().compare(callStack[callStackPtr-1])==0)) {
						correctState = es;
					}
				}


				}
			}
		}
		if (correctState==NULL) {
			std::cerr<<"maybe this execution already be killed due to fault\n";
			//temp solution pick any path
			correctState = *(states.begin());
			states.clear();
		}
		return *correctState;
	}
	do {
	int minDis = infinity;
	std::vector<ExecutionState*> potentialminState;
	std::vector<int> potentialminVal;
	ExecutionState* minState;
//	std::cerr<<"reach here picking state?? "<<callStackPtr<<"\n";

	for (std::vector<ExecutionState*>::iterator it = states.begin(),
	             ie = states.end(); it != ie; ++it) {
		ExecutionState *es = *it;
		BasicBlock* nextbb = es->pc->inst->getParent();
		int dis = infinity;
		if (es->stack.size()<=callStackPtr+1+initenvpos) {
			//have to patch current
			BasicBlock* curbb = nextbb;
			int stackidx = es->stack.size()-1;
			while (this->curDistanceMap.find(curbb)==this->curDistanceMap.end()&&stackidx>=0) {
				stackidx--;
				curbb = es->stack[stackidx].caller->inst->getParent();
	//			std::cerr<<"step one back\n";
			}
			//std::cerr<<curbb->getNameStr()<<"\n";
			dis = this->curDistanceMap[curbb];
			if (changeTargetBB!=NULL) {
				if (changeTargetReachFlag.find(es)==changeTargetReachFlag.end()) {
					dis+=this->changeTargetDisMap[curbb];
			//		std::cerr << "change dis :" << this->changeTargetDisMap[curbb]<<"\n";
				}
			}
		}
		else if (es->stack.size()>callStackPtr+1+initenvpos) {
			BasicBlock* curbb = nextbb;
			int stackidx = es->stack.size()-1;
			while (this->curDistanceMap.find(curbb)!=this->curDistanceMap.end()&&this->curDistanceMap[curbb]==infinity&&stackidx>callStackPtr+initenvpos) {
				stackidx--;
				curbb = es->stack[stackidx].caller->inst->getParent();
	//			std::cerr<<"step one back\n";
			}
			dis = this->curDistanceMap[curbb];
			if (changeTargetBB!=NULL) {
					if (changeTargetReachFlag.find(es)==changeTargetReachFlag.end()) {
						dis+=this->changeTargetDisMap[curbb];
					}
			}
//			StackFrame sf = es->stack[callStackPtr+initenvpos];
//			dis = this->curDistanceMap[sf.caller->inst->getParent()];
		}
//		std::cerr <<es->pc->info->file<<" @ "<< es->pc->info->line << " stack size" << es->stack.size() << "dis " << dis<<"\n";

		if (dis<infinity&&es->stack.size()>=callStackPtr+initenvpos) {
			bool sameCallStack = true;
			unsigned checkstacksize = 0;
			if (callStackPtr+initenvpos==es->stack.size())
				checkstacksize = callStackPtr+initenvpos;
			else
				checkstacksize = callStackPtr+1+initenvpos;
			for (unsigned i=1+initenvpos;i<checkstacksize;i++) {
				StackFrame sf = es->stack[i];
				KInstruction* kinst = sf.caller;
				std::ostringstream osstream;
				osstream << kinst->info->file <<":"<<kinst->info->line;

			//	std::cerr<<kinst->info->line<<"\n";
				if (kinst->inst->getParent()!=targetBBList[i-1-initenvpos]||(osstream.str().compare(callStack[i-1-initenvpos])!=0)) {
					sameCallStack = false;
					break;
				}
				//if (sf->)
			}
			if (sameCallStack) {
				if ((es->stack.size()==callStackPtr+initenvpos)&&(callStackPtr>0)) {

					std::ostringstream osstream;
					osstream << es->pc->info->file <<":"<<es->pc->info->line;

					if (es->pc->inst->getParent()==targetBBList[callStackPtr-1]&&(osstream.str().compare(callStack[callStackPtr-1])==0)) {
						dis = dis-1;
						BasicBlock* parentBB = es->pc->inst->getParent();
						for (BasicBlock::iterator BBI = parentBB->begin(),BBE = parentBB->end();BBI!=BBE;BBI++) {
							Instruction* bbinst = BBI;
							if (isa<CallInst>(bbinst)) {
				//				std::cerr << "get call site\n";
								if (((CallInst*)bbinst)->getCalledFunction()==NULL) {
									continue;
								}
								BasicBlock* calledEntry = &(((CallInst*)bbinst)->getCalledFunction()->getEntryBlock());
								if (this->curDistanceMap[calledEntry]<infinity) {
									dis = this->curDistanceMap[calledEntry];
									if (changeTargetBB!=NULL) {
											if (changeTargetReachFlag.find(es)==changeTargetReachFlag.end()) {
												dis+=this->changeTargetDisMap[calledEntry];
											}
									}
									break;
								}
							}
						}
						potentialminState.push_back(es);
						potentialminVal.push_back(dis);
						//minState = es;
						if (dis==0) {
							minDis = dis;
							minState = es;
						}

//						std::cerr << "min dis set\n";
					}
				} else {
					potentialminState.push_back(es);
					potentialminVal.push_back(dis);
					if (dis==0) {
												minDis = dis;
												minState = es;
											}
	//				std::cerr << "min dis set\n";
				}
			}
		}


	}
	if (minDis>0) {
	double totalVal = 0;
	for (std::vector<int>::iterator it = potentialminVal.begin(),
	             ie = potentialminVal.end(); it != ie; ++it) {
		totalVal+=1.00/((double)(*it));
	}
	double rng = theRNG.getDoubleL();
	//std::cerr<<"rng : "<<rng << " potentialminVal : "<< potentialminVal.size() ;
	double curSum = 0;
	for (unsigned i =0;i<potentialminVal.size();i++) {
		double curTemp = 1.00/((double)(potentialminVal[i]));
		if (curSum/totalVal<=rng&&(curSum+curTemp)/totalVal>rng) {
			minDis = potentialminVal[i];
			minState = potentialminState[i];
//			std::cerr<<" picked number "<<i<<"\n";
			break;
		}
		double v1 = curSum/totalVal;
		double v2 = (curSum+curTemp)/totalVal;
//		std::cerr<<"["<<v1<<","<<v2<<"]\n";
		curSum+=curTemp;
	}
	}

	if (minDis<infinity) {
		std::cerr << "picked " <<minState->pc->info->file<<":"<< minState->pc->info->line << " stack size" << minState->stack.size() <<" min Dis "<<minDis<<"\n";

		std::ostringstream osstream;
		osstream << minState->pc->info->file <<":"<<minState->pc->info->line;

		if (minState->pc->inst->getParent()==changeTargetBB&&osstream.str().compare(changeTargetSource)==0) {
			if (changeTargetReachFlag.find(minState)==changeTargetReachFlag.end())
				changeTargetReachFlag[minState] = 1;
		}

		if (minState->pc->inst->getParent()==targetBBList[callStackPtr]&&(osstream.str().compare(callStack[callStackPtr])==0)) {

		//	llvm::errs() << "cur pc stack size" << minState->stack.size();
			if (minState->stack.size()==callStackPtr+1+initenvpos) {

				callStackPtr++;
				if (callStackPtr==callStack.size()) {
					std::cerr << "reach target clear other states dump pc\n";
					this->getTarget = true;
					//states.clear();
				} else {
					std::cerr << callStackPtr <<" "<<callStack.size()<< " reach partial important move step forward\n";
					findNextTarget();
				}
			}
		}
		return *minState;
	} else {
		if (callStackPtr==0)
			break;
		callStackPtr--;
		std::cerr << callStackPtr <<" "<<callStack.size()<< " have to perform backtracing move step back\n";
			findNextTarget();
		}
	} while (true);
		//clear states
		std::cerr<<"min Dis is infinity\n";
		ExecutionState* retVal = NULL;
		for (std::vector<ExecutionState*>::iterator it = states.begin(),
		             ie = states.end(); it != ie; ++it) {
			ExecutionState *es = *it;
			BasicBlock* nextbb = es->pc->inst->getParent();
			if (nextbb==targetBBList[callStackPtr]) {
				retVal = es;
			}
		}
		states.clear();
		return *retVal;
}

void ShortestPathSearcher::update(ExecutionState *current,
                         const std::set<ExecutionState*> &addedStates,
                         const std::set<ExecutionState*> &removedStates) {
  states.insert(states.end(),
                addedStates.begin(),
                addedStates.end());
  for (std::set<ExecutionState*>::const_iterator it = removedStates.begin(),
         ie = removedStates.end(); it != ie; ++it) {
    ExecutionState *es = *it;
    if (es == states.back()) {
      states.pop_back();
    } else {
      bool ok = false;

      for (std::vector<ExecutionState*>::iterator ait = states.begin(),
             aie = states.end(); ait != aie; ++ait) {
        if (es==*ait) {
          states.erase(ait);
          ok = true;
          break;
        }
      }

      assert(ok && "invalid state removed");
    }
  }
}


///

ExecutionState &DFSSearcher::selectState() {
//	ExecutionState* es = states.back();
//	es->
  return *states.back();
}

void DFSSearcher::update(ExecutionState *current,
                         const std::set<ExecutionState*> &addedStates,
                         const std::set<ExecutionState*> &removedStates) {
  states.insert(states.end(),
                addedStates.begin(),
                addedStates.end());
  for (std::set<ExecutionState*>::const_iterator it = removedStates.begin(),
         ie = removedStates.end(); it != ie; ++it) {
    ExecutionState *es = *it;
    if (es == states.back()) {
      states.pop_back();
    } else {
      bool ok = false;

      for (std::vector<ExecutionState*>::iterator it = states.begin(),
             ie = states.end(); it != ie; ++it) {
        if (es==*it) {
          states.erase(it);
          ok = true;
          break;
        }
      }

      assert(ok && "invalid state removed");
    }
  }
}

///

ExecutionState &RandomSearcher::selectState() {
  return *states[theRNG.getInt32()%states.size()];
}

void RandomSearcher::update(ExecutionState *current,
                            const std::set<ExecutionState*> &addedStates,
                            const std::set<ExecutionState*> &removedStates) {
  states.insert(states.end(),
                addedStates.begin(),
                addedStates.end());
  for (std::set<ExecutionState*>::const_iterator it = removedStates.begin(),
         ie = removedStates.end(); it != ie; ++it) {
    ExecutionState *es = *it;
    bool ok = false;

    for (std::vector<ExecutionState*>::iterator it = states.begin(),
           ie = states.end(); it != ie; ++it) {
      if (es==*it) {
        states.erase(it);
        ok = true;
        break;
      }
    }
    
    assert(ok && "invalid state removed");
  }
}

///

WeightedRandomSearcher::WeightedRandomSearcher(Executor &_executor,
                                               WeightType _type) 
  : executor(_executor),
    states(new DiscretePDF<ExecutionState*>()),
    type(_type) {
  switch(type) {
  case Depth: 
    updateWeights = false;
    break;
  case InstCount:
  case CPInstCount:
  case QueryCost:
  case MinDistToUncovered:
  case CoveringNew:
    updateWeights = true;
    break;
  default:
    assert(0 && "invalid weight type");
  }
}

WeightedRandomSearcher::~WeightedRandomSearcher() {
  delete states;
}

ExecutionState &WeightedRandomSearcher::selectState() {
  return *states->choose(theRNG.getDoubleL());
}

double WeightedRandomSearcher::getWeight(ExecutionState *es) {
  switch(type) {
  default:
  case Depth: 
    return es->weight;
  case InstCount: {
    uint64_t count = theStatisticManager->getIndexedValue(stats::instructions,
                                                          es->pc->info->id);
    double inv = 1. / std::max((uint64_t) 1, count);
    return inv * inv;
  }
  case CPInstCount: {
    StackFrame &sf = es->stack.back();
    uint64_t count = sf.callPathNode->statistics.getValue(stats::instructions);
    double inv = 1. / std::max((uint64_t) 1, count);
    return inv;
  }
  case QueryCost:
    return (es->queryCost < .1) ? 1. : 1./es->queryCost;
  case CoveringNew:
  case MinDistToUncovered: {
    uint64_t md2u = computeMinDistToUncovered(es->pc,
                                              es->stack.back().minDistToUncoveredOnReturn);

    double invMD2U = 1. / (md2u ? md2u : 10000);
    if (type==CoveringNew) {
      double invCovNew = 0.;
      if (es->instsSinceCovNew)
        invCovNew = 1. / std::max(1, (int) es->instsSinceCovNew - 1000);
      return (invCovNew * invCovNew + invMD2U * invMD2U);
    } else {
      return invMD2U * invMD2U;
    }
  }
  }
}

void WeightedRandomSearcher::update(ExecutionState *current,
                                    const std::set<ExecutionState*> &addedStates,
                                    const std::set<ExecutionState*> &removedStates) {
  if (current && updateWeights && !removedStates.count(current))
    states->update(current, getWeight(current));
  
  for (std::set<ExecutionState*>::const_iterator it = addedStates.begin(),
         ie = addedStates.end(); it != ie; ++it) {
    ExecutionState *es = *it;
    states->insert(es, getWeight(es));
  }

  for (std::set<ExecutionState*>::const_iterator it = removedStates.begin(),
         ie = removedStates.end(); it != ie; ++it) {
    states->remove(*it);
  }
}

bool WeightedRandomSearcher::empty() { 
  return states->empty(); 
}

///

RandomPathSearcher::RandomPathSearcher(Executor &_executor)
  : executor(_executor) {
}

RandomPathSearcher::~RandomPathSearcher() {
}

ExecutionState &RandomPathSearcher::selectState() {
  unsigned flips=0, bits=0;
  PTree::Node *n = executor.processTree->root;
  
  while (!n->data) {
    if (!n->left) {
      n = n->right;
    } else if (!n->right) {
      n = n->left;
    } else {
      if (bits==0) {
        flips = theRNG.getInt32();
        bits = 32;
      }
      --bits;
      n = (flips&(1<<bits)) ? n->left : n->right;
    }
  }

  return *n->data;
}

void RandomPathSearcher::update(ExecutionState *current,
                                const std::set<ExecutionState*> &addedStates,
                                const std::set<ExecutionState*> &removedStates) {
}

bool RandomPathSearcher::empty() { 
  return executor.states.empty(); 
}

///

BumpMergingSearcher::BumpMergingSearcher(Executor &_executor, Searcher *_baseSearcher) 
  : executor(_executor),
    baseSearcher(_baseSearcher),
    mergeFunction(executor.kmodule->kleeMergeFn) {
}

BumpMergingSearcher::~BumpMergingSearcher() {
  delete baseSearcher;
}

///

Instruction *BumpMergingSearcher::getMergePoint(ExecutionState &es) {  
  if (mergeFunction) {
    Instruction *i = es.pc->inst;

    if (i->getOpcode()==Instruction::Call) {
      CallSite cs(cast<CallInst>(i));
      if (mergeFunction==cs.getCalledFunction())
        return i;
    }
  }

  return 0;
}

ExecutionState &BumpMergingSearcher::selectState() {
entry:
  // out of base states, pick one to pop
  if (baseSearcher->empty()) {
    std::map<llvm::Instruction*, ExecutionState*>::iterator it = 
      statesAtMerge.begin();
    ExecutionState *es = it->second;
    statesAtMerge.erase(it);
    ++es->pc;

    baseSearcher->addState(es);
  }

  ExecutionState &es = baseSearcher->selectState();

  if (Instruction *mp = getMergePoint(es)) {
    std::map<llvm::Instruction*, ExecutionState*>::iterator it = 
      statesAtMerge.find(mp);

    baseSearcher->removeState(&es);

    if (it==statesAtMerge.end()) {
      statesAtMerge.insert(std::make_pair(mp, &es));
    } else {
      ExecutionState *mergeWith = it->second;
      if (mergeWith->merge(es)) {
        // hack, because we are terminating the state we need to let
        // the baseSearcher know about it again
        baseSearcher->addState(&es);
        executor.terminateState(es);
      } else {
        it->second = &es; // the bump
        ++mergeWith->pc;

        baseSearcher->addState(mergeWith);
      }
    }

    goto entry;
  } else {
    return es;
  }
}

void BumpMergingSearcher::update(ExecutionState *current,
                                 const std::set<ExecutionState*> &addedStates,
                                 const std::set<ExecutionState*> &removedStates) {
  baseSearcher->update(current, addedStates, removedStates);
}

///

MergingSearcher::MergingSearcher(Executor &_executor, Searcher *_baseSearcher) 
  : executor(_executor),
    baseSearcher(_baseSearcher),
    mergeFunction(executor.kmodule->kleeMergeFn) {
}

MergingSearcher::~MergingSearcher() {
  delete baseSearcher;
}

///

Instruction *MergingSearcher::getMergePoint(ExecutionState &es) {
  if (mergeFunction) {
    Instruction *i = es.pc->inst;

    if (i->getOpcode()==Instruction::Call) {
      CallSite cs(cast<CallInst>(i));
      if (mergeFunction==cs.getCalledFunction())
        return i;
    }
  }

  return 0;
}

ExecutionState &MergingSearcher::selectState() {
  while (!baseSearcher->empty()) {
    ExecutionState &es = baseSearcher->selectState();
    if (getMergePoint(es)) {
      baseSearcher->removeState(&es, &es);
      statesAtMerge.insert(&es);
    } else {
      return es;
    }
  }
  
  // build map of merge point -> state list
  std::map<Instruction*, std::vector<ExecutionState*> > merges;
  for (std::set<ExecutionState*>::const_iterator it = statesAtMerge.begin(),
         ie = statesAtMerge.end(); it != ie; ++it) {
    ExecutionState &state = **it;
    Instruction *mp = getMergePoint(state);
    
    merges[mp].push_back(&state);
  }
  
  if (DebugLogMerge)
    std::cerr << "-- all at merge --\n";
  for (std::map<Instruction*, std::vector<ExecutionState*> >::iterator
         it = merges.begin(), ie = merges.end(); it != ie; ++it) {
    if (DebugLogMerge) {
      std::cerr << "\tmerge: " << it->first << " [";
      for (std::vector<ExecutionState*>::iterator it2 = it->second.begin(),
             ie2 = it->second.end(); it2 != ie2; ++it2) {
        ExecutionState *state = *it2;
        std::cerr << state << ", ";
      }
      std::cerr << "]\n";
    }

    // merge states
    std::set<ExecutionState*> toMerge(it->second.begin(), it->second.end());
    while (!toMerge.empty()) {
      ExecutionState *base = *toMerge.begin();
      toMerge.erase(toMerge.begin());
      
      std::set<ExecutionState*> toErase;
      for (std::set<ExecutionState*>::iterator it = toMerge.begin(),
             ie = toMerge.end(); it != ie; ++it) {
        ExecutionState *mergeWith = *it;
        
        if (base->merge(*mergeWith)) {
          toErase.insert(mergeWith);
        }
      }
      if (DebugLogMerge && !toErase.empty()) {
        std::cerr << "\t\tmerged: " << base << " with [";
        for (std::set<ExecutionState*>::iterator it = toErase.begin(),
               ie = toErase.end(); it != ie; ++it) {
          if (it!=toErase.begin()) std::cerr << ", ";
          std::cerr << *it;
        }
        std::cerr << "]\n";
      }
      for (std::set<ExecutionState*>::iterator it = toErase.begin(),
             ie = toErase.end(); it != ie; ++it) {
        std::set<ExecutionState*>::iterator it2 = toMerge.find(*it);
        assert(it2!=toMerge.end());
        executor.terminateState(**it);
        toMerge.erase(it2);
      }

      // step past merge and toss base back in pool
      statesAtMerge.erase(statesAtMerge.find(base));
      ++base->pc;
      baseSearcher->addState(base);
    }  
  }
  
  if (DebugLogMerge)
    std::cerr << "-- merge complete, continuing --\n";
  
  return selectState();
}

void MergingSearcher::update(ExecutionState *current,
                             const std::set<ExecutionState*> &addedStates,
                             const std::set<ExecutionState*> &removedStates) {
  if (!removedStates.empty()) {
    std::set<ExecutionState *> alt = removedStates;
    for (std::set<ExecutionState*>::const_iterator it = removedStates.begin(),
           ie = removedStates.end(); it != ie; ++it) {
      ExecutionState *es = *it;
      std::set<ExecutionState*>::const_iterator it = statesAtMerge.find(es);
      if (it!=statesAtMerge.end()) {
        statesAtMerge.erase(it);
        alt.erase(alt.find(es));
      }
    }    
    baseSearcher->update(current, addedStates, alt);
  } else {
    baseSearcher->update(current, addedStates, removedStates);
  }
}

///

BatchingSearcher::BatchingSearcher(Searcher *_baseSearcher,
                                   double _timeBudget,
                                   unsigned _instructionBudget) 
  : baseSearcher(_baseSearcher),
    timeBudget(_timeBudget),
    instructionBudget(_instructionBudget),
    lastState(0) {
  
}

BatchingSearcher::~BatchingSearcher() {
  delete baseSearcher;
}

ExecutionState &BatchingSearcher::selectState() {
  if (!lastState || 
      (util::getWallTime()-lastStartTime)>timeBudget ||
      (stats::instructions-lastStartInstructions)>instructionBudget) {
    if (lastState) {
      double delta = util::getWallTime()-lastStartTime;
      if (delta>timeBudget*1.1) {
        std::cerr << "KLEE: increased time budget from " << timeBudget << " to " << delta << "\n";
        timeBudget = delta;
      }
    }
    lastState = &baseSearcher->selectState();
    lastStartTime = util::getWallTime();
    lastStartInstructions = stats::instructions;
    return *lastState;
  } else {
    return *lastState;
  }
}

void BatchingSearcher::update(ExecutionState *current,
                              const std::set<ExecutionState*> &addedStates,
                              const std::set<ExecutionState*> &removedStates) {
  if (removedStates.count(lastState))
    lastState = 0;
  baseSearcher->update(current, addedStates, removedStates);
}

/***/

IterativeDeepeningTimeSearcher::IterativeDeepeningTimeSearcher(Searcher *_baseSearcher)
  : baseSearcher(_baseSearcher),
    time(1.) {
}

IterativeDeepeningTimeSearcher::~IterativeDeepeningTimeSearcher() {
  delete baseSearcher;
}

ExecutionState &IterativeDeepeningTimeSearcher::selectState() {
  ExecutionState &res = baseSearcher->selectState();
  startTime = util::getWallTime();
  return res;
}

void IterativeDeepeningTimeSearcher::update(ExecutionState *current,
                                            const std::set<ExecutionState*> &addedStates,
                                            const std::set<ExecutionState*> &removedStates) {
  double elapsed = util::getWallTime() - startTime;

  if (!removedStates.empty()) {
    std::set<ExecutionState *> alt = removedStates;
    for (std::set<ExecutionState*>::const_iterator it = removedStates.begin(),
           ie = removedStates.end(); it != ie; ++it) {
      ExecutionState *es = *it;
      std::set<ExecutionState*>::const_iterator it = pausedStates.find(es);
      if (it!=pausedStates.end()) {
        pausedStates.erase(it);
        alt.erase(alt.find(es));
      }
    }    
    baseSearcher->update(current, addedStates, alt);
  } else {
    baseSearcher->update(current, addedStates, removedStates);
  }

  if (current && !removedStates.count(current) && elapsed>time) {
    pausedStates.insert(current);
    baseSearcher->removeState(current);
  }

  if (baseSearcher->empty()) {
    time *= 2;
    std::cerr << "KLEE: increasing time budget to: " << time << "\n";
    baseSearcher->update(0, pausedStates, std::set<ExecutionState*>());
    pausedStates.clear();
  }
}

/***/

InterleavedSearcher::InterleavedSearcher(const std::vector<Searcher*> &_searchers)
  : searchers(_searchers),
    index(1) {
}

InterleavedSearcher::~InterleavedSearcher() {
  for (std::vector<Searcher*>::const_iterator it = searchers.begin(),
         ie = searchers.end(); it != ie; ++it)
    delete *it;
}

ExecutionState &InterleavedSearcher::selectState() {
  Searcher *s = searchers[--index];
  if (index==0) index = searchers.size();
  return s->selectState();
}

void InterleavedSearcher::update(ExecutionState *current,
                                 const std::set<ExecutionState*> &addedStates,
                                 const std::set<ExecutionState*> &removedStates) {
  for (std::vector<Searcher*>::const_iterator it = searchers.begin(),
         ie = searchers.end(); it != ie; ++it)
    (*it)->update(current, addedStates, removedStates);
}
